{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MCCE website \u00b6 MCCE (Multi-Conformation Continuum Electrostatics) is a biophysics simulation program combining continuum electrostatics and molecular mechanics. In this program, the protein side chain motions are simulated explicitly while the dielectric effect of solvent and bulk protein material is modeled by continuum electrostatics. What can MCCE do? \u00b6 MCCE can calculate: residue pka, cofactor Em and protein PI in protein-solvent systems; protein structural responses to changes in charge; residue ionization changes in response to protein structural changes; location and stoichiometry of proton transfers coupled to electron transfer Project at a Glance: \u00b6 MCCE is a program developed at Marilyn Gunner's lab in City College of New York. Current development focuses are on the following aspects: change residue/cofactor topology file into free format to make the procedure of integrating a new ligand easier. make program friendly to distribute and easy to maintain. develop tool sets to analyze MCCE results. develop protein pKa database to include all known structures listed in the PDB.","title":"Overview"},{"location":"#welcome-to-mcce-website","text":"MCCE (Multi-Conformation Continuum Electrostatics) is a biophysics simulation program combining continuum electrostatics and molecular mechanics. In this program, the protein side chain motions are simulated explicitly while the dielectric effect of solvent and bulk protein material is modeled by continuum electrostatics.","title":"Welcome to MCCE website"},{"location":"#what-can-mcce-do","text":"MCCE can calculate: residue pka, cofactor Em and protein PI in protein-solvent systems; protein structural responses to changes in charge; residue ionization changes in response to protein structural changes; location and stoichiometry of proton transfers coupled to electron transfer","title":"What can MCCE do?"},{"location":"#project-at-a-glance","text":"MCCE is a program developed at Marilyn Gunner's lab in City College of New York. Current development focuses are on the following aspects: change residue/cofactor topology file into free format to make the procedure of integrating a new ligand easier. make program friendly to distribute and easy to maintain. develop tool sets to analyze MCCE results. develop protein pKa database to include all known structures listed in the PDB.","title":"Project at a Glance:"},{"location":"developers/flow/","text":"Python MCCE \u00b6 A Python version of Multi-Conformation Continuum Electrostatics simulation program to model protein electrostatic interactions. Program Mechanism \u00b6 A protein or protein complex structure is broken down into pieces, usually amino acid residues and cofactors. Each piece may have charge, protonation, and position conformers. These peices interact with each other, and the piece conformers are sampled by Monte Carlo sampling to find their probabilty of occupancy at various conditions, such as pH, redox potention, chemical potential, and introduced charges. Program Structure \u00b6 Step 1: Break structue into residues \u00b6 graph TD A1 ( run . prm ) --> B1 (( read prm )) A2 ( input . pdb ) --> C1 (( read pdb )) A3 ( tpl files ) --> B4 (( read tpl )) subgraph Step 0 : Load run control and tpl files B1 --> B2 [ run_prm db ] B1 --> B4 B4 --> B5 [ tpl db ] end B2 --> C1 B5 --> C1 subgraph Step 1 : Break into residues C1 --> C2 (( verify pdb )) C2 --> C3 (( to residues )) C3 --> C4 (( missing atoms )) C4 --> C5 (( ligand bonds )) C5 --> C6 (( NTR , CTR )) end C6 --> C7 ( step1_out . pdb ) C6 --> C8 ( head1 . lst ) Step 2: Make residue conformers \u00b6 graph TD A1 ( run . prm ) --> B1 (( read prm )) A3 ( tpl files ) --> B4 (( read tpl )) subgraph Step 0 : Load run control and tpl files B1 --> B2 [ run_prm db ] B1 --> B4 B4 --> B5 [ tpl db ] end B2 --> C1 B5 --> C1 B6 ( step1_out . pdb ) --> C1 B7 ( head1 . lst ) --> C1 (( readin )) subgraph Step 2 : Make residue conformers C1 --> C2 (( charge < br /> conformers )) C2 --> C3 (( position < br /> conformers )) C3 --> C4 (( hbond < br /> conformers )) end C4 --> C5 ( step2_out . pdb ) C4 --> C6 ( head2 . lst ) Step 3. Compute energy table \u00b6 graph TD A1 ( run . prm ) --> B1 (( read prm )) A3 ( tpl files ) --> B4 (( read tpl )) subgraph Step 0 : Load run control and tpl files B1 --> B2 [ run_prm db ] B1 --> B4 B4 --> B5 [ tpl db ] end B2 --> C1 B6 ( step2_out . pdb ) --> C1 (( readin )) subgraph Step 3 : Make residue conformers C1 --> C2 (( RXN delphi )) C2 --> C3 (( PW delphi )) C3 --> C4 (( boundary < br /> correction )) end C4 --> C5 ( energies /*.opp) C4-->C6(head3.lst) Step 4. Monte Carlo sampling: accessible states \u00b6 graph TB A1 ( energies /*.opp) --> B1 ( readin ) A2 ( head3 . lst ) --> B1 A3 ( run . prm ) --> A4 (( read prm )) A4 --> A5 [ prm db ] A5 --> B1 B1 --> B2 (( group into residues )) B2 --> B3 (( verify flags )) B3 --> B4 (( big list )) B4 --> B5 (( loop over pH )) B5 --> B6 (( independent < br \\ > runs )) B6 --> B7 (( Monte Carlo sampling )) B7 --> B7 .1 (( record state )) B7 .1 --> B8 { over ? } B8 -- no --> B6 B8 -- yes --> B9 { next pH ? } B9 -- no --> B5 B9 -- yes --> B10 (( end ))","title":"Python MCCE"},{"location":"developers/flow/#python-mcce","text":"A Python version of Multi-Conformation Continuum Electrostatics simulation program to model protein electrostatic interactions.","title":"Python MCCE"},{"location":"developers/flow/#program-mechanism","text":"A protein or protein complex structure is broken down into pieces, usually amino acid residues and cofactors. Each piece may have charge, protonation, and position conformers. These peices interact with each other, and the piece conformers are sampled by Monte Carlo sampling to find their probabilty of occupancy at various conditions, such as pH, redox potention, chemical potential, and introduced charges.","title":"Program Mechanism"},{"location":"developers/flow/#program-structure","text":"","title":"Program Structure"},{"location":"developers/flow/#step-1-break-structue-into-residues","text":"graph TD A1 ( run . prm ) --> B1 (( read prm )) A2 ( input . pdb ) --> C1 (( read pdb )) A3 ( tpl files ) --> B4 (( read tpl )) subgraph Step 0 : Load run control and tpl files B1 --> B2 [ run_prm db ] B1 --> B4 B4 --> B5 [ tpl db ] end B2 --> C1 B5 --> C1 subgraph Step 1 : Break into residues C1 --> C2 (( verify pdb )) C2 --> C3 (( to residues )) C3 --> C4 (( missing atoms )) C4 --> C5 (( ligand bonds )) C5 --> C6 (( NTR , CTR )) end C6 --> C7 ( step1_out . pdb ) C6 --> C8 ( head1 . lst )","title":"Step 1: Break structue into residues"},{"location":"developers/flow/#step-2-make-residue-conformers","text":"graph TD A1 ( run . prm ) --> B1 (( read prm )) A3 ( tpl files ) --> B4 (( read tpl )) subgraph Step 0 : Load run control and tpl files B1 --> B2 [ run_prm db ] B1 --> B4 B4 --> B5 [ tpl db ] end B2 --> C1 B5 --> C1 B6 ( step1_out . pdb ) --> C1 B7 ( head1 . lst ) --> C1 (( readin )) subgraph Step 2 : Make residue conformers C1 --> C2 (( charge < br /> conformers )) C2 --> C3 (( position < br /> conformers )) C3 --> C4 (( hbond < br /> conformers )) end C4 --> C5 ( step2_out . pdb ) C4 --> C6 ( head2 . lst )","title":"Step 2: Make residue conformers"},{"location":"developers/flow/#step-3-compute-energy-table","text":"graph TD A1 ( run . prm ) --> B1 (( read prm )) A3 ( tpl files ) --> B4 (( read tpl )) subgraph Step 0 : Load run control and tpl files B1 --> B2 [ run_prm db ] B1 --> B4 B4 --> B5 [ tpl db ] end B2 --> C1 B6 ( step2_out . pdb ) --> C1 (( readin )) subgraph Step 3 : Make residue conformers C1 --> C2 (( RXN delphi )) C2 --> C3 (( PW delphi )) C3 --> C4 (( boundary < br /> correction )) end C4 --> C5 ( energies /*.opp) C4-->C6(head3.lst)","title":"Step 3. Compute energy table"},{"location":"developers/flow/#step-4-monte-carlo-sampling-accessible-states","text":"graph TB A1 ( energies /*.opp) --> B1 ( readin ) A2 ( head3 . lst ) --> B1 A3 ( run . prm ) --> A4 (( read prm )) A4 --> A5 [ prm db ] A5 --> B1 B1 --> B2 (( group into residues )) B2 --> B3 (( verify flags )) B3 --> B4 (( big list )) B4 --> B5 (( loop over pH )) B5 --> B6 (( independent < br \\ > runs )) B6 --> B7 (( Monte Carlo sampling )) B7 --> B7 .1 (( record state )) B7 .1 --> B8 { over ? } B8 -- no --> B6 B8 -- yes --> B9 { next pH ? } B9 -- no --> B5 B9 -- yes --> B10 (( end ))","title":"Step 4. Monte Carlo sampling: accessible states"},{"location":"developers/mkdocs/","text":"How to write documentation \u00b6 This documentation is written in mkdocs, which uses markdown language and publishes on github pages . Installation of Mkdocs \u00b6 #!/usr/bin/env bash pip install --upgrade pip pip install bs4 pip install unicode pip install mkdocs pip install mkdocs-material pip install pymdown-extensions pip install markdown-blockdiag pip install markdown-include This will install mkdocs, theme, and necessary plugins for documentation of this project. Writing and editing \u00b6 All documentation files reside under folder wiki/ mkdocs.yml : configuration file, also defines the menu docs/users/ : location of documentation files for users docs/developers/ : location of documentation files for developers site/ : site web pages published by command mkdocs gh-deploy Under wiki/ directory, run mkdocs serve will bring up a web service, and point browser to http://localhost:8000 to enable viewing and debugging the documentation. Deploying \u00b6 To deploy site, you can create a pull request so that the GunnerLab repo administrator can merge and deploy for you. or deploy directly by running gh-deploy under directory wiki/. You need GunnerLab repo member permission to do this. If gh-deploy reports conflict in special branch gh-pages, use \"--force\" switch to overwrite: mkdocs gh-deploy --force The published site is on: https://gunnerlab.github.io/Develop-MCCE/ . Markdown languange references \u00b6 Basic syntax: https://www.markdownguide.org/cheat-sheet/ More on syntax: https://alinex.gitlab.io/env/mkdocs/ Diagram: http://blockdiag.com/en/blockdiag/ PyDown: https://facelessuser.github.io/pymdown-extensions/extensions/arithmatex/","title":"Writing Documentation"},{"location":"developers/mkdocs/#how-to-write-documentation","text":"This documentation is written in mkdocs, which uses markdown language and publishes on github pages .","title":"How to write documentation"},{"location":"developers/mkdocs/#installation-of-mkdocs","text":"#!/usr/bin/env bash pip install --upgrade pip pip install bs4 pip install unicode pip install mkdocs pip install mkdocs-material pip install pymdown-extensions pip install markdown-blockdiag pip install markdown-include This will install mkdocs, theme, and necessary plugins for documentation of this project.","title":"Installation of Mkdocs"},{"location":"developers/mkdocs/#writing-and-editing","text":"All documentation files reside under folder wiki/ mkdocs.yml : configuration file, also defines the menu docs/users/ : location of documentation files for users docs/developers/ : location of documentation files for developers site/ : site web pages published by command mkdocs gh-deploy Under wiki/ directory, run mkdocs serve will bring up a web service, and point browser to http://localhost:8000 to enable viewing and debugging the documentation.","title":"Writing and editing"},{"location":"developers/mkdocs/#deploying","text":"To deploy site, you can create a pull request so that the GunnerLab repo administrator can merge and deploy for you. or deploy directly by running gh-deploy under directory wiki/. You need GunnerLab repo member permission to do this. If gh-deploy reports conflict in special branch gh-pages, use \"--force\" switch to overwrite: mkdocs gh-deploy --force The published site is on: https://gunnerlab.github.io/Develop-MCCE/ .","title":"Deploying"},{"location":"developers/mkdocs/#markdown-languange-references","text":"Basic syntax: https://www.markdownguide.org/cheat-sheet/ More on syntax: https://alinex.gitlab.io/env/mkdocs/ Diagram: http://blockdiag.com/en/blockdiag/ PyDown: https://facelessuser.github.io/pymdown-extensions/extensions/arithmatex/","title":"Markdown languange references"},{"location":"developers/notes/","text":"Suggestions to developers \u00b6 Tip Use Python 3 Read PEP 8 ( https://www.python.org/dev/peps/pep-0008/ ) Read PEP 20 ( https://www.python.org/dev/peps/pep-0020/ ) Put constants, data structure and reusable functions in pymccelib.py so that the main program keeps focus on program flow. Put all python scripts in bin/ Put all program documentation in markdown language in /wiki/docs/ Print and log messages \u00b6 Use print() to print program result and logging module to print messages, allowing users to set verbose mode and level, and module functions to run at quiet mode. logging levels and sample usage \u00b6 Task What to use Display program output print() Debug information logging.debug() Confirmation that things are working as expected logging.info() Warning but program is still running logging.warning() Unexpected error that may cause program to stop or produce wrong result logging.error() Serious error that will break the program logging.critical() Example of using logging in a program \u00b6 #!/usr/bin/env python import logging def welcome (): logging . info ( \"Welcome from function!\" ) return if __name__ == \"__main__\" : # Set logging level. DEBUG, INFO, WARNING, ERROR and CRITICAL are in the order from more details to less logging . basicConfig ( level = logging . DEBUG , format = ' %(message)s ' ) logging . info ( \"Welcome from main program!\" ) welcome () Attention The logging.basicConfig() can only be declared only once, and before any logging messages! Python tutorials and books \u00b6 Beginner books \u00b6 Python Crash Course by Eric Matthes, 2 nd Edition. Find on Amazon . Comprehensive reference \u00b6 Programming Python by Mark Lutz, 4 th Edition. Find it on Amazon . Advanced books \u00b6 Python Cookbook by David Beazley and Brian Jones, Third edition. Find it on Amazon .","title":"Notes to Developers"},{"location":"developers/notes/#suggestions-to-developers","text":"Tip Use Python 3 Read PEP 8 ( https://www.python.org/dev/peps/pep-0008/ ) Read PEP 20 ( https://www.python.org/dev/peps/pep-0020/ ) Put constants, data structure and reusable functions in pymccelib.py so that the main program keeps focus on program flow. Put all python scripts in bin/ Put all program documentation in markdown language in /wiki/docs/","title":"Suggestions to developers"},{"location":"developers/notes/#print-and-log-messages","text":"Use print() to print program result and logging module to print messages, allowing users to set verbose mode and level, and module functions to run at quiet mode.","title":"Print and log messages"},{"location":"developers/notes/#logging-levels-and-sample-usage","text":"Task What to use Display program output print() Debug information logging.debug() Confirmation that things are working as expected logging.info() Warning but program is still running logging.warning() Unexpected error that may cause program to stop or produce wrong result logging.error() Serious error that will break the program logging.critical()","title":"logging levels and sample usage"},{"location":"developers/notes/#example-of-using-logging-in-a-program","text":"#!/usr/bin/env python import logging def welcome (): logging . info ( \"Welcome from function!\" ) return if __name__ == \"__main__\" : # Set logging level. DEBUG, INFO, WARNING, ERROR and CRITICAL are in the order from more details to less logging . basicConfig ( level = logging . DEBUG , format = ' %(message)s ' ) logging . info ( \"Welcome from main program!\" ) welcome () Attention The logging.basicConfig() can only be declared only once, and before any logging messages!","title":"Example of using logging in a program"},{"location":"developers/notes/#python-tutorials-and-books","text":"","title":"Python tutorials and books"},{"location":"developers/notes/#beginner-books","text":"Python Crash Course by Eric Matthes, 2 nd Edition. Find on Amazon .","title":"Beginner books"},{"location":"developers/notes/#comprehensive-reference","text":"Programming Python by Mark Lutz, 4 th Edition. Find it on Amazon .","title":"Comprehensive reference"},{"location":"developers/notes/#advanced-books","text":"Python Cookbook by David Beazley and Brian Jones, Third edition. Find it on Amazon .","title":"Advanced books"},{"location":"developers/pymccelib_pdb/","text":"PDB IO \u00b6 Info After importing the library, you have access to the constants, attributes and functions: >>> from pymccelib import * This part of functions handle the reading and writing of PDB files. MCCE protein structure organization \u00b6 The structure is organized as a hierarchical data structure as Protein -> Residue -> Conformer -> Atom. Each residue contains one or multiple conformers. The first conformer is special. It contains atoms that are considered to be backbone, which do not change charge and position in MCCE sampling. Conformers other than the first conformer are candidates to compose a microstate, which consists one conformer from each residue. Read/write a pdb \u00b6 MCCE PDB format \u00b6 ATOM 8 CB VAL A0003_001 17.786 38.593 41.279 2.000 0.000 01____M000 Column (0 based) Definition Format Example 0-5 Record name %6s ATOM 6-10 Serial number %5d 2 12-15 Atom name %4s CB 17-19 Residue name %3s VAL 21 Chain ID %c A 22-25 Sequence number %04d 0003 1 26 Insertion code %c _ 2 27-29 Conformer number %03d 001 1 30-37 X coordinate %8.3f 17.786 38-45 Y coordinate %8.3f 38.593 46-53 Z coordinate %8.3f 41.279 54-61 PB radius %8.3f 2.000 66-73 Charge %8.3f 0.000 80- Conformer history %s 01____M000 3 1 : Filled with 0, and will later be used to compose conformer ID string. 2 : If no insertion code, MCCE uses \"_\", and will later be used to compose conformer ID string. 3 : Conformer making history: Column 1-2: conformer type as a two letter code in residue CONFLIST in ftpl file. \"BK\", \"01\", \"02\", \"+1\" etc Column 3: Rotamer making mechanism, a one letter code. Column 4-6: Rotamer number, reindexed for each mechanism indicated by column 3. Column 7: H atom placing mechanism, a one letter code. Column 8-10: Rotamer number, reindexed for each mechanism indicated by column 7. Rotamer making mechanism code explained, for column 3: \"O\" = original \"R\" = rotated, sampled by repacking with neighboring residues \"X\" = most exposed \"H\" = hydrogen-bond directed Rotamer making mechanism code explained, for column 7: \"M\" = torsion minimum \"H\" = hydrogen-bond directed Protein.load_nativepdb(pdb) \u00b6 Load native pdb file into Protein data structure. Example: from pymccelib import * env . init () # get pdb file name from run.prm pdbfile = env . prm ( \"INPDB\" ) # initialize a protein object prot = Protein () # load pdb file prot . load_nativepdb ( pdbfile ) Description: This subroutine does: Read pdb file in native format (PDB format) and store in mcce protein hierarchical structure. Read a PDB pdb file \u00b6 Read a MCCE pdb file \u00b6 Write a pdb file \u00b6 Write mcce protein data structure to array of lines ready to output to stdout or file. Example: prot=Protein() ... lines = prot.pdblines() sys.stdout.writelines(lines) Description: This subroutine does: Read pdb file in native format (PDB format) and store in mcce protein hierarchical structure.","title":"PDB IO"},{"location":"developers/pymccelib_pdb/#pdb-io","text":"Info After importing the library, you have access to the constants, attributes and functions: >>> from pymccelib import * This part of functions handle the reading and writing of PDB files.","title":"PDB IO"},{"location":"developers/pymccelib_pdb/#mcce-protein-structure-organization","text":"The structure is organized as a hierarchical data structure as Protein -> Residue -> Conformer -> Atom. Each residue contains one or multiple conformers. The first conformer is special. It contains atoms that are considered to be backbone, which do not change charge and position in MCCE sampling. Conformers other than the first conformer are candidates to compose a microstate, which consists one conformer from each residue.","title":"MCCE protein structure organization"},{"location":"developers/pymccelib_pdb/#readwrite-a-pdb","text":"","title":"Read/write a pdb"},{"location":"developers/pymccelib_pdb/#mcce-pdb-format","text":"ATOM 8 CB VAL A0003_001 17.786 38.593 41.279 2.000 0.000 01____M000 Column (0 based) Definition Format Example 0-5 Record name %6s ATOM 6-10 Serial number %5d 2 12-15 Atom name %4s CB 17-19 Residue name %3s VAL 21 Chain ID %c A 22-25 Sequence number %04d 0003 1 26 Insertion code %c _ 2 27-29 Conformer number %03d 001 1 30-37 X coordinate %8.3f 17.786 38-45 Y coordinate %8.3f 38.593 46-53 Z coordinate %8.3f 41.279 54-61 PB radius %8.3f 2.000 66-73 Charge %8.3f 0.000 80- Conformer history %s 01____M000 3 1 : Filled with 0, and will later be used to compose conformer ID string. 2 : If no insertion code, MCCE uses \"_\", and will later be used to compose conformer ID string. 3 : Conformer making history: Column 1-2: conformer type as a two letter code in residue CONFLIST in ftpl file. \"BK\", \"01\", \"02\", \"+1\" etc Column 3: Rotamer making mechanism, a one letter code. Column 4-6: Rotamer number, reindexed for each mechanism indicated by column 3. Column 7: H atom placing mechanism, a one letter code. Column 8-10: Rotamer number, reindexed for each mechanism indicated by column 7. Rotamer making mechanism code explained, for column 3: \"O\" = original \"R\" = rotated, sampled by repacking with neighboring residues \"X\" = most exposed \"H\" = hydrogen-bond directed Rotamer making mechanism code explained, for column 7: \"M\" = torsion minimum \"H\" = hydrogen-bond directed","title":"MCCE PDB format"},{"location":"developers/pymccelib_pdb/#proteinload_nativepdbpdb","text":"Load native pdb file into Protein data structure. Example: from pymccelib import * env . init () # get pdb file name from run.prm pdbfile = env . prm ( \"INPDB\" ) # initialize a protein object prot = Protein () # load pdb file prot . load_nativepdb ( pdbfile ) Description: This subroutine does: Read pdb file in native format (PDB format) and store in mcce protein hierarchical structure.","title":"Protein.load_nativepdb(pdb)"},{"location":"developers/pymccelib_pdb/#read-a-pdb-pdb-file","text":"","title":"Read a PDB pdb file"},{"location":"developers/pymccelib_pdb/#read-a-mcce-pdb-file","text":"","title":"Read a MCCE pdb file"},{"location":"developers/pymccelib_pdb/#write-a-pdb-file","text":"Write mcce protein data structure to array of lines ready to output to stdout or file. Example: prot=Protein() ... lines = prot.pdblines() sys.stdout.writelines(lines) Description: This subroutine does: Read pdb file in native format (PDB format) and store in mcce protein hierarchical structure.","title":"Write a pdb file"},{"location":"developers/pymccelib_prmtpl/","text":"Paramters IO \u00b6 Info After importing the library, you have access to the constants, attributes and functions: >>> from pymccelib import * Constants \u00b6 These are global variables ROOMT \u00b6 Definition: Room temperature. Example: >>> from pymccelib import * >>> print ( ROOMT ) 298.15 PH2KCAL \u00b6 Definition: Conversion from 1 pH unit to kcal/mol. Example: >>> from pymccelib import * >>> print ( PH2KCAL ) 1.364 KCAL2KT \u00b6 Definition: Conversion from 1 kcal/mol to KT Example: >>> from pymccelib import * >>> print ( KCAL2KT ) 1.688 KJ2KCAL \u00b6 Definition: Conversion from 1kj/mol to kcal/mol. Example: >>> from pymccelib import * >>> print ( KJ2KCAL ) 0.239 MCCE run environment \u00b6 MCCE run environment can be retrieved from dictionary env.prm. Both key and values are in string type. run.prm \u2192 env.prm \u00b6 The file run.prm is translated to env.prm line by line. The last string in parenthesis is the key, and the first string is the value. In file run.prm, line f step 1: pdb -> mcce pdb (DO_PREMCCE) translates to: env.prm[\"DO_MCCE\"] = \"f\" and line 1.0 pH interval (TITR_PHD) translates to: env.prm[TITR_PHD] = \"1.0\" Accessing env.prm \u00b6 Example: To access env.prm as a dictionary. >>> from pymccelib import * # import >>> env . init () # load run.prm and ftpl files >>> print ( env . prm ) # print out env.prm { 'INPDB' : 'prot.pdb' , 'DO_PREMCCE' : 'f' , 'DO_ROTAMERS' : 'f' , 'DO_ENERGY' : 'f' , 'DO_MONTE' : 'f' , 'TPL_FOLDER' : '/home/jmao/projects/Develop-MCCE/param' , 'EXTRA' : './extra.ftpl' , 'TITR_TYPE' : 'ph' , 'TITR_PH0' : '0.0' , 'TITR_PHD' : '1.0' , 'TITR_EH0' : '0.0' , 'TITR_EHD' : '30.0' , 'TITR_STEPS' : '15' , 'BIG_PAIRWISE' : '5.0' , 'MONTE_FLIPS' : '3' , 'MONTE_T' : '298.15' , 'MONTE_NITER' : '2000' , 'MONTE_RUNS' : '6' , 'NSTATE_MAX' : '1000000' } To access individual parameter: >>> print(env.prm[\"DO_PREMCCE\"]) f Exceptions and defaults \u00b6 In run.prm, if a key is missing, or \"DEFAULT\" is used, the value will be interpreted in the context of the key. Example: DEFAULT tpl file folder path, \"DEFAULT\" to launch location (TPL_FOLDER) The key TPL_FOLDER will be assigned a default value. TPL_FOLDER \u00b6 Topology file folder. Default is relative location \" ../param \" to the executable location. The above example demonstrates where pymcce.py looks for topology files *.ftpl. DELPHI_EXE \u00b6 The path of PB solver delphi. Default is the same directory where the main executable resides. The above example demonstrates where delphi executable is if pymcce.py was the main program. Scaling factors \u00b6 Scaling factors are used by step 4, microstate sampling. Name Definition Default SCALING_VDW0 Scaling factor of intra-conformer VDW \"1.0\" SCALING_VDW1 Scaling factor of sidechain to backbone VDW \"1.0\" SCALING_VDW Scaling factor of sidechain to sidechain VDW \" 1.0\" SCALING_TORS Scaling factor of torsion energy \" 1.0\" SCALING_ELE Scaling factor of electrostatic interaction \" 1.0\" SCALING_DSOLV Scaling factor of desolvation energy \" 1.0\" Topology records \u00b6 These records hold definitions of ligands, conformers, and molecular parameters. The records are located as dictionary in env.tpl. ftpl -> env.tpl \u00b6 Topology file is now free format. It has up to three keys, and a string as value. Key and value are separated by \":\", and three parts of key are separated by \",\". Example: CONNECT, \" N \", GLUBK: sp2, \" ? \", \" CA \", \" H \" After converted, it is: env.tpl[(CONNECT, \" N \", GLUBK)] = 'sp2, \" ? \", \" CA \", \" H \"' Rules of reading ftpl files: Comments: Anything after \"#\" will not be read. Free format: Spaces are ignored unless inside quotes. Delimiter of key and value: \":\" divides key and value. Delimiter of key parts: \",\" divides key parts. There can be up to 3 parts of a key. Enclosing space in key and value: space can be key or value when enclosed in quotes. Records with identical key: the later key-value pair will overwrite the previous, with a warning. Order of reading ftpl files: ftpl files in param/ folder are read in alphabetic order and extra.ftpl defined in run.prm is read last. Native and derived tpl entries \u00b6 Native entries are directly translated from ftpl files. All values are strings. Native entries \u00b6 Primary Key Key example Explanation CONFLIST (\"CONFLIST\", \"GLU\") returns a conformer list from a residue name CONNECT (\"CONNECT\", \" N \", \"GLUBK\") returns orbital type and a list of connected atoms CHARGE (\"CHARGE\", \"GLUBK\", \" N \") returns atom charge RADIUS (\"RADIUS\", \"GLUBK\", \" N \") dielectric boundary radius, VDW radius and energy well depth CONFORMER (\"CONFORMER\", \"GLU01\") Conformer self energy terms ROTATE (\"ROTATE\", \"GLU\") Residue rotatable bonds Note Native entries are stored in env.tpl{}. Derived entries \u00b6 Derived entries are converted or structured entries derived from native entries. Name Example Explanation env.atomenames{} env.atomnames[\"GLUBK\"] atom names derived from CONNECT records Note Derived entries are stored in separate env attributes. Accessing env.tpl \u00b6 Native and derived tpl entries can be accessed by visiting respected dictionaries in env. Value data type varies. Example >>> from pymccelib import * >>> env . init () >>> print ( env . tpl [( \"CHARGE\" , \"GLUBK\" , \" N \" )]) - 0.350 >>> print ( env . atomnames [ \"GLU01\" ]) [ ' CB ' , ' HB2' , ' HB3' , ' CG ' , ' HG2' , ' HG3' , ' CD ' , ' OE1' , ' HE1' , ' OE2' ] Functions in env \u00b6 env.init() \u00b6 Initialize mcce running environment. Synopsis: env.init() Description: This subroutine does: Read run.prm, and set default values for missing parameters. Read param/*.ftpl and extra.ftpl; initialize env.tpl{} and derived tpl entries. env.print_runprm() \u00b6 Print all env.prm entries Synopsis: env.print_runprm() This subroutine prints out all env.prm entries for debug purpose. env.print_scaling() \u00b6 Print all scaling factors Synopsis: env.print_scaling() This subroutine prints out scaling factors used by microstate sampling for debug purpose. load_ftpl(self, file) \u00b6 Load an individual ftpl file Synopsis: env.load_ftpl(ftpl_file_path) This subroutine loads an individual ftpl file. MCCE loads all ftple files from location defined by line (TPL_FOLDER) in run.prm. One can load additional ftpl files to supplement or overwrite entries previously defined.","title":"Reading Parameters"},{"location":"developers/pymccelib_prmtpl/#paramters-io","text":"Info After importing the library, you have access to the constants, attributes and functions: >>> from pymccelib import *","title":"Paramters IO"},{"location":"developers/pymccelib_prmtpl/#constants","text":"These are global variables","title":"Constants"},{"location":"developers/pymccelib_prmtpl/#roomt","text":"Definition: Room temperature. Example: >>> from pymccelib import * >>> print ( ROOMT ) 298.15","title":"ROOMT"},{"location":"developers/pymccelib_prmtpl/#ph2kcal","text":"Definition: Conversion from 1 pH unit to kcal/mol. Example: >>> from pymccelib import * >>> print ( PH2KCAL ) 1.364","title":"PH2KCAL"},{"location":"developers/pymccelib_prmtpl/#kcal2kt","text":"Definition: Conversion from 1 kcal/mol to KT Example: >>> from pymccelib import * >>> print ( KCAL2KT ) 1.688","title":"KCAL2KT"},{"location":"developers/pymccelib_prmtpl/#kj2kcal","text":"Definition: Conversion from 1kj/mol to kcal/mol. Example: >>> from pymccelib import * >>> print ( KJ2KCAL ) 0.239","title":"KJ2KCAL"},{"location":"developers/pymccelib_prmtpl/#mcce-run-environment","text":"MCCE run environment can be retrieved from dictionary env.prm. Both key and values are in string type.","title":"MCCE run environment"},{"location":"developers/pymccelib_prmtpl/#runprm-envprm","text":"The file run.prm is translated to env.prm line by line. The last string in parenthesis is the key, and the first string is the value. In file run.prm, line f step 1: pdb -> mcce pdb (DO_PREMCCE) translates to: env.prm[\"DO_MCCE\"] = \"f\" and line 1.0 pH interval (TITR_PHD) translates to: env.prm[TITR_PHD] = \"1.0\"","title":"run.prm --&gt; env.prm"},{"location":"developers/pymccelib_prmtpl/#accessing-envprm","text":"Example: To access env.prm as a dictionary. >>> from pymccelib import * # import >>> env . init () # load run.prm and ftpl files >>> print ( env . prm ) # print out env.prm { 'INPDB' : 'prot.pdb' , 'DO_PREMCCE' : 'f' , 'DO_ROTAMERS' : 'f' , 'DO_ENERGY' : 'f' , 'DO_MONTE' : 'f' , 'TPL_FOLDER' : '/home/jmao/projects/Develop-MCCE/param' , 'EXTRA' : './extra.ftpl' , 'TITR_TYPE' : 'ph' , 'TITR_PH0' : '0.0' , 'TITR_PHD' : '1.0' , 'TITR_EH0' : '0.0' , 'TITR_EHD' : '30.0' , 'TITR_STEPS' : '15' , 'BIG_PAIRWISE' : '5.0' , 'MONTE_FLIPS' : '3' , 'MONTE_T' : '298.15' , 'MONTE_NITER' : '2000' , 'MONTE_RUNS' : '6' , 'NSTATE_MAX' : '1000000' } To access individual parameter: >>> print(env.prm[\"DO_PREMCCE\"]) f","title":"Accessing env.prm"},{"location":"developers/pymccelib_prmtpl/#exceptions-and-defaults","text":"In run.prm, if a key is missing, or \"DEFAULT\" is used, the value will be interpreted in the context of the key. Example: DEFAULT tpl file folder path, \"DEFAULT\" to launch location (TPL_FOLDER) The key TPL_FOLDER will be assigned a default value.","title":"Exceptions and defaults"},{"location":"developers/pymccelib_prmtpl/#tpl_folder","text":"Topology file folder. Default is relative location \" ../param \" to the executable location. The above example demonstrates where pymcce.py looks for topology files *.ftpl.","title":"TPL_FOLDER"},{"location":"developers/pymccelib_prmtpl/#delphi_exe","text":"The path of PB solver delphi. Default is the same directory where the main executable resides. The above example demonstrates where delphi executable is if pymcce.py was the main program.","title":"DELPHI_EXE"},{"location":"developers/pymccelib_prmtpl/#scaling-factors","text":"Scaling factors are used by step 4, microstate sampling. Name Definition Default SCALING_VDW0 Scaling factor of intra-conformer VDW \"1.0\" SCALING_VDW1 Scaling factor of sidechain to backbone VDW \"1.0\" SCALING_VDW Scaling factor of sidechain to sidechain VDW \" 1.0\" SCALING_TORS Scaling factor of torsion energy \" 1.0\" SCALING_ELE Scaling factor of electrostatic interaction \" 1.0\" SCALING_DSOLV Scaling factor of desolvation energy \" 1.0\"","title":"Scaling factors"},{"location":"developers/pymccelib_prmtpl/#topology-records","text":"These records hold definitions of ligands, conformers, and molecular parameters. The records are located as dictionary in env.tpl.","title":"Topology records"},{"location":"developers/pymccelib_prmtpl/#ftpl-envtpl","text":"Topology file is now free format. It has up to three keys, and a string as value. Key and value are separated by \":\", and three parts of key are separated by \",\". Example: CONNECT, \" N \", GLUBK: sp2, \" ? \", \" CA \", \" H \" After converted, it is: env.tpl[(CONNECT, \" N \", GLUBK)] = 'sp2, \" ? \", \" CA \", \" H \"' Rules of reading ftpl files: Comments: Anything after \"#\" will not be read. Free format: Spaces are ignored unless inside quotes. Delimiter of key and value: \":\" divides key and value. Delimiter of key parts: \",\" divides key parts. There can be up to 3 parts of a key. Enclosing space in key and value: space can be key or value when enclosed in quotes. Records with identical key: the later key-value pair will overwrite the previous, with a warning. Order of reading ftpl files: ftpl files in param/ folder are read in alphabetic order and extra.ftpl defined in run.prm is read last.","title":"ftpl -&gt; env.tpl"},{"location":"developers/pymccelib_prmtpl/#native-and-derived-tpl-entries","text":"Native entries are directly translated from ftpl files. All values are strings.","title":"Native and derived tpl entries"},{"location":"developers/pymccelib_prmtpl/#native-entries","text":"Primary Key Key example Explanation CONFLIST (\"CONFLIST\", \"GLU\") returns a conformer list from a residue name CONNECT (\"CONNECT\", \" N \", \"GLUBK\") returns orbital type and a list of connected atoms CHARGE (\"CHARGE\", \"GLUBK\", \" N \") returns atom charge RADIUS (\"RADIUS\", \"GLUBK\", \" N \") dielectric boundary radius, VDW radius and energy well depth CONFORMER (\"CONFORMER\", \"GLU01\") Conformer self energy terms ROTATE (\"ROTATE\", \"GLU\") Residue rotatable bonds Note Native entries are stored in env.tpl{}.","title":"Native entries"},{"location":"developers/pymccelib_prmtpl/#derived-entries","text":"Derived entries are converted or structured entries derived from native entries. Name Example Explanation env.atomenames{} env.atomnames[\"GLUBK\"] atom names derived from CONNECT records Note Derived entries are stored in separate env attributes.","title":"Derived entries"},{"location":"developers/pymccelib_prmtpl/#accessing-envtpl","text":"Native and derived tpl entries can be accessed by visiting respected dictionaries in env. Value data type varies. Example >>> from pymccelib import * >>> env . init () >>> print ( env . tpl [( \"CHARGE\" , \"GLUBK\" , \" N \" )]) - 0.350 >>> print ( env . atomnames [ \"GLU01\" ]) [ ' CB ' , ' HB2' , ' HB3' , ' CG ' , ' HG2' , ' HG3' , ' CD ' , ' OE1' , ' HE1' , ' OE2' ]","title":"Accessing env.tpl"},{"location":"developers/pymccelib_prmtpl/#functions-in-env","text":"","title":"Functions in env"},{"location":"developers/pymccelib_prmtpl/#envinit","text":"Initialize mcce running environment. Synopsis: env.init() Description: This subroutine does: Read run.prm, and set default values for missing parameters. Read param/*.ftpl and extra.ftpl; initialize env.tpl{} and derived tpl entries.","title":"env.init()"},{"location":"developers/pymccelib_prmtpl/#envprint_runprm","text":"Print all env.prm entries Synopsis: env.print_runprm() This subroutine prints out all env.prm entries for debug purpose.","title":"env.print_runprm()"},{"location":"developers/pymccelib_prmtpl/#envprint_scaling","text":"Print all scaling factors Synopsis: env.print_scaling() This subroutine prints out scaling factors used by microstate sampling for debug purpose.","title":"env.print_scaling()"},{"location":"developers/pymccelib_prmtpl/#load_ftplself-file","text":"Load an individual ftpl file Synopsis: env.load_ftpl(ftpl_file_path) This subroutine loads an individual ftpl file. MCCE loads all ftple files from location defined by line (TPL_FOLDER) in run.prm. One can load additional ftpl files to supplement or overwrite entries previously defined.","title":"load_ftpl(self, file)"},{"location":"developers/sharecode_git/","text":"Collaborate through GIT \u00b6 Tip: Git/github Cheat Sheet If you need a quick reference of setting up and using git/github, find git cheat sheet here . Sample workflow \u00b6 To collaborate with others on this project, please fork from the GunnerLab Develop-MCCE repository . The detailed steps are illustrated in the following example: Create an issue on group repo \u00b6 Tell others what you are working on by creating an issue. To create an issue, go to https://github.com/GunnerLab/Develop-MCCE , and create a new issue. After an issue is created, a number will be returned. Create a branch on local repo \u00b6 Suppose I am going to write code to address the issue created by someone else or myself, and the issue number is #30. The issue title is \"Develop script to install Mkdocs and recommended plugins\" Now I go to the forked repo directory on my local computer, make sure I have remote referenc set up correctly: ( base ) jmao@vivo:~/projects/Develop-MCCE$ git remote -v origin https://github.com/newbooks/Develop-MCCE.git ( fetch ) origin https://github.com/newbooks/Develop-MCCE.git ( push ) upstream https://github.com/GunnerLab/Develop-MCCE.git ( fetch ) upstream https://github.com/GunnerLab/Develop-MCCE.git ( push ) Before I create a branch, update the master from upstream so all existing code is up to date. ( base ) jmao@vivo:~/projects/Develop-MCCE$ git checkout master Already on 'master' Your branch is ahead of 'origin/master' by 7 commits. ( use \"git push\" to publish your local commits ) ( base ) jmao@vivo:~/projects/Develop-MCCE$ git pull upstream master From https://github.com/GunnerLab/Develop-MCCE * branch master -> FETCH_HEAD Already up to date. It's time to create a new local branch that matches the issue number: ( base ) jmao@vivo:~/projects/Develop-MCCE$ git checkout -b issue#30 Develop code under branch \u00b6 In this example, I create a file install_mkdocs.sh under bin. #!/bin/bash pip install --upgrade pip pip install bs4 pip install unicode pip install mkdocs pip install mkdocs-material pip install pymdown-extensions pip install markdown-blockdiag pip install markdown-include Go to wiki directory and run mkdocs serve Then point browser to URL http://localhost:8000 to monitor mkdocs page. If everything goes well, the documentation site should be up. Any edits under wiki will be reflected by the above page. When it is ready to deploy as a github page, run mkdocs gh-deploy This will create another branch, which is a special branch linked to Github page, and pushed to Github automatically. So in this example, I actually end up with two branches: issue#30 gh-pages (already pushed to Github by mkdocs gh-deploy ) We only need to manually commit and push branch issue#30 git add bin/ git commit -a -m \"Added script to install mkdocs. closes #30\" git push --set-upstream origin issue#30 \"closes #30\" in commit will tell Github to close the issue #30 at the time of merging to the upstream. Create pull request \u00b6 After the changes are pushed to origin, go to your forked repository. Tips The most recently pushed branch should appear separately, and a button to create pull request next to it. This is a shortcut to make pull request. Under tab <> Code, change the branch to issue#30, then use the button on the right to make a new pull quest. The GunnerLab repo manager will review and approve your pull request. Clean up \u00b6 Once the pull request is approved, the changes are compiled into the master branch of the main repository, and the branch issue#30 in your fork and local repository can be deleted. Under your local repo, git checkout master # switch from branch to master git pull upstream master # sync from upstream git branch delete issue#30 # delete the local issue branch git push origin --delete issue#30 # delete remote issue branch Now both the local and upstream repo have the up to date code. Tips Coding should take place only in issue branches. Master branch should be used only to sync from the upstream, and serve as a starting point of making your issue branches. This helps to avoid conflicts between upstream and forked repo.","title":"Git Sample Workflow"},{"location":"developers/sharecode_git/#collaborate-through-git","text":"Tip: Git/github Cheat Sheet If you need a quick reference of setting up and using git/github, find git cheat sheet here .","title":"Collaborate through GIT"},{"location":"developers/sharecode_git/#sample-workflow","text":"To collaborate with others on this project, please fork from the GunnerLab Develop-MCCE repository . The detailed steps are illustrated in the following example:","title":"Sample workflow"},{"location":"developers/sharecode_git/#create-an-issue-on-group-repo","text":"Tell others what you are working on by creating an issue. To create an issue, go to https://github.com/GunnerLab/Develop-MCCE , and create a new issue. After an issue is created, a number will be returned.","title":"Create an issue on group repo"},{"location":"developers/sharecode_git/#create-a-branch-on-local-repo","text":"Suppose I am going to write code to address the issue created by someone else or myself, and the issue number is #30. The issue title is \"Develop script to install Mkdocs and recommended plugins\" Now I go to the forked repo directory on my local computer, make sure I have remote referenc set up correctly: ( base ) jmao@vivo:~/projects/Develop-MCCE$ git remote -v origin https://github.com/newbooks/Develop-MCCE.git ( fetch ) origin https://github.com/newbooks/Develop-MCCE.git ( push ) upstream https://github.com/GunnerLab/Develop-MCCE.git ( fetch ) upstream https://github.com/GunnerLab/Develop-MCCE.git ( push ) Before I create a branch, update the master from upstream so all existing code is up to date. ( base ) jmao@vivo:~/projects/Develop-MCCE$ git checkout master Already on 'master' Your branch is ahead of 'origin/master' by 7 commits. ( use \"git push\" to publish your local commits ) ( base ) jmao@vivo:~/projects/Develop-MCCE$ git pull upstream master From https://github.com/GunnerLab/Develop-MCCE * branch master -> FETCH_HEAD Already up to date. It's time to create a new local branch that matches the issue number: ( base ) jmao@vivo:~/projects/Develop-MCCE$ git checkout -b issue#30","title":"Create a branch on local repo"},{"location":"developers/sharecode_git/#develop-code-under-branch","text":"In this example, I create a file install_mkdocs.sh under bin. #!/bin/bash pip install --upgrade pip pip install bs4 pip install unicode pip install mkdocs pip install mkdocs-material pip install pymdown-extensions pip install markdown-blockdiag pip install markdown-include Go to wiki directory and run mkdocs serve Then point browser to URL http://localhost:8000 to monitor mkdocs page. If everything goes well, the documentation site should be up. Any edits under wiki will be reflected by the above page. When it is ready to deploy as a github page, run mkdocs gh-deploy This will create another branch, which is a special branch linked to Github page, and pushed to Github automatically. So in this example, I actually end up with two branches: issue#30 gh-pages (already pushed to Github by mkdocs gh-deploy ) We only need to manually commit and push branch issue#30 git add bin/ git commit -a -m \"Added script to install mkdocs. closes #30\" git push --set-upstream origin issue#30 \"closes #30\" in commit will tell Github to close the issue #30 at the time of merging to the upstream.","title":"Develop code under branch"},{"location":"developers/sharecode_git/#create-pull-request","text":"After the changes are pushed to origin, go to your forked repository. Tips The most recently pushed branch should appear separately, and a button to create pull request next to it. This is a shortcut to make pull request. Under tab <> Code, change the branch to issue#30, then use the button on the right to make a new pull quest. The GunnerLab repo manager will review and approve your pull request.","title":"Create pull request"},{"location":"developers/sharecode_git/#clean-up","text":"Once the pull request is approved, the changes are compiled into the master branch of the main repository, and the branch issue#30 in your fork and local repository can be deleted. Under your local repo, git checkout master # switch from branch to master git pull upstream master # sync from upstream git branch delete issue#30 # delete the local issue branch git push origin --delete issue#30 # delete remote issue branch Now both the local and upstream repo have the up to date code. Tips Coding should take place only in issue branches. Master branch should be used only to sync from the upstream, and serve as a starting point of making your issue branches. This helps to avoid conflicts between upstream and forked repo.","title":"Clean up"},{"location":"developers/structure/","text":"Program Structure \u00b6 Main program: \u00b6 pymcce.py \u00b6 This program works like the c version main program. It integrates the four steps in one program and use run.prm to to control which steps are executed. Individual steps \u00b6 Individual steps can run as standalone programs or be called by main program. These steps exchange data by files. premcce.py: convert to mcce pdb \u00b6 Premcce.py reads a pdb file, and converts it to mcce pdb. In this process, the structure will have terminal residues and certain cofactors renamed to appropriate names so they can have proper ionization states and conformers. Solvent and salt molecules are stripped off according to the rules in run.prm. Head1.lst is a instruction file for the next step to make side chain ionization and conformation conformers. The default instruction is based on the rules in run.prm, and users can customize this file for more controls. mkconf.py: make conformers \u00b6 Ionization and conformation conformers are recorded in step2_out.pdb. Head2.lst is formational, it records the rotamer making history and statistics. mkenergy.py: caculate energy table \u00b6 Mkenergy.py is the energy calculation step. It reads in step2_out.pdb and compute the side chain conformer pairwise interaction in energies/ directory, and side chain conformer self energy terms in head3.lst. monte.py: Monte Carlo sampling of states \u00b6 Monte.py samples the side chain conformer occupancy therefore reports the probabilty of ionization at different conditions. Fort.38 is a conformer occupancy file, mc_out records the Monte Carlo progress including energy tracing, and microstates/*.ms are the microstates records in the sampling. Supporting modules: \u00b6 pymccelib.py: mcce modules \u00b6 MCCE data structures and modules geometry.py: geometry operations \u00b6 Geometry operations Analysis tools: \u00b6 A collection fof analysis tools. fitpka.py: Titration curve fitting \u00b6 mfe.py: use mean field to analyze free energy \u00b6","title":"Program Structure"},{"location":"developers/structure/#program-structure","text":"","title":"Program Structure"},{"location":"developers/structure/#main-program","text":"","title":"Main program:"},{"location":"developers/structure/#pymccepy","text":"This program works like the c version main program. It integrates the four steps in one program and use run.prm to to control which steps are executed.","title":"pymcce.py"},{"location":"developers/structure/#individual-steps","text":"Individual steps can run as standalone programs or be called by main program. These steps exchange data by files.","title":"Individual steps"},{"location":"developers/structure/#premccepy-convert-to-mcce-pdb","text":"Premcce.py reads a pdb file, and converts it to mcce pdb. In this process, the structure will have terminal residues and certain cofactors renamed to appropriate names so they can have proper ionization states and conformers. Solvent and salt molecules are stripped off according to the rules in run.prm. Head1.lst is a instruction file for the next step to make side chain ionization and conformation conformers. The default instruction is based on the rules in run.prm, and users can customize this file for more controls.","title":"premcce.py: convert to mcce pdb"},{"location":"developers/structure/#mkconfpy-make-conformers","text":"Ionization and conformation conformers are recorded in step2_out.pdb. Head2.lst is formational, it records the rotamer making history and statistics.","title":"mkconf.py: make conformers"},{"location":"developers/structure/#mkenergypy-caculate-energy-table","text":"Mkenergy.py is the energy calculation step. It reads in step2_out.pdb and compute the side chain conformer pairwise interaction in energies/ directory, and side chain conformer self energy terms in head3.lst.","title":"mkenergy.py: caculate energy table"},{"location":"developers/structure/#montepy-monte-carlo-sampling-of-states","text":"Monte.py samples the side chain conformer occupancy therefore reports the probabilty of ionization at different conditions. Fort.38 is a conformer occupancy file, mc_out records the Monte Carlo progress including energy tracing, and microstates/*.ms are the microstates records in the sampling.","title":"monte.py: Monte Carlo sampling of states"},{"location":"developers/structure/#supporting-modules","text":"","title":"Supporting modules:"},{"location":"developers/structure/#pymccelibpy-mcce-modules","text":"MCCE data structures and modules","title":"pymccelib.py: mcce modules"},{"location":"developers/structure/#geometrypy-geometry-operations","text":"Geometry operations","title":"geometry.py: geometry operations"},{"location":"developers/structure/#analysis-tools","text":"A collection fof analysis tools.","title":"Analysis tools:"},{"location":"developers/structure/#fitpkapy-titration-curve-fitting","text":"","title":"fitpka.py: Titration curve fitting"},{"location":"developers/structure/#mfepy-use-mean-field-to-analyze-free-energy","text":"","title":"mfe.py: use mean field to analyze free energy"}]}